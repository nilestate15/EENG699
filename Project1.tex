\documentclass[12pt]{article}

\usepackage[
   paperheight = 11in,
   paperwidth = 8.5in,
   margin = 1in,
   footskip = 0.45in] {geometry} %  custom paper size and margins
\usepackage{graphicx}
\usepackage{float}
\usepackage{adjustbox}
\usepackage{color} %  custom colors
\usepackage{multicol}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{hhline}
\usepackage{titlesec}
\usepackage{hyphenat}
\usepackage{array}
\usepackage{graphicx}
\usepackage{upquote}
\usepackage[
   colorlinks = true,
   linkcolor = darkblue,
   urlcolor = darkblue,
   hypertexnames = false]{hyperref}

\setlength{\tabcolsep}{10pt}
\def\arraystretch{1.2}
%\setlist{nolistsep}
\definecolor{gray}         {rgb}{0.50,0.50,0.50}
\definecolor{darkblue}     {rgb}{0.00,0.00,0.50}
\renewcommand{\labelenumi}{\arabic{enumi}.}
\renewcommand{\labelenumii}{\alph{enumii}.}
\setlength{\parindent}{0em}
\setlength{\parskip}{10pt plus 2pt minus 2pt}
\titlespacing\section{0pt}{10pt plus 2pt minus 2pt}{0pt plus 2pt minus 2pt}
\raggedbottom
\newcolumntype{L}[1]{>{
   \raggedright\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}
\newcolumntype{C}[1]{>{
   \centering\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}
\newcolumntype{R}[1]{>{
   \raggedleft\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}

\begin{document}
%  Header
\begin{minipage}{0.9\textwidth}
   \raggedright
   \large \textbf{\textsf{{\color{gray}EENG 533: Navigation Using GPS} \\
      Project 1: Coordinate Frame Conversions}}
\end{minipage}
\vspace{1cm}

\section*{\textsf{Objectives}}

\begin{enumerate}
   \item Increase proficiency in Python programming and investigate the numPy, SciPy, and Matplotlib libraries
   \item Demonstrate the ability to do various types of coordinate
      transformations
   \item Understand the difference between Cartesian and surface representations
      of local level coordinates
   \item Determine the region over which a local level frame is consistent with
      a surface-defined frame.
\end{enumerate}

\section*{\textsf{Overview}}

In this lab, you will convert a flight trajectory into a local level frame using
the two different methods described in class.  Once this is done, you will
evaluate the results in order to get insight into the differences between a
Cartesian representation and a surface-based representation.

\section*{\textsf{Collaboration}}

This is an individual laboratory.  You may discuss this lab with other students.
However, all source code that you generate and use and anything you turn in must
be your own.

\section*{\textsf{Local-Level Coordinates}}

The file \texttt{proj1\_flight\_trajectory.mat} has a trajectory of an aircraft
flying southeast at 300~m/s at 1000~m altitude starting in Dayton.

It can be loaded with the helper code near the top of \texttt{project1\_template.py}.
%It is a data file and can be loaded into MATLAB using the standard load command:
%\begin{verbatim}
%   K = load('proj1_flight_trajectory.mat';
%\end{verbatim}
%It has a structure with four vectors: \texttt{t} (time), \texttt{lat} (latitude
%in radians), \texttt{lon} (longitude in radians), and \texttt{h} (height above
%the ellipsoidal surface of the Earth).

The contained values are all geodetic coordinates relative to the WGS-84 ellipsoid.
%If you are interested, you can look to see how the coordinates were generated by
%the MATLAB script \texttt{gen\_flight\_trajectory.m}.  (Note: you do not need
%to look at this script or change it to accomplish anything in this project).

\begin{figure}[H] %  <- "*}" for full width; "[H]" to not float
   \centering
   \includegraphics[scale = 0.3] %  <- add "[angle=90,origin=c]" to rotate
   {map.png} %  <- name of file here
   \caption{Map of the trajectory over the US.} %  <- remove for no caption
   \label{fig_trajectory} %  <- remove for no number
\end{figure} %  <- "*}" for full width

For this task, you should convert the entire trajectory into local level
coordinates using the two different methods that are described in the ``Local
Level Coordinates'' video: ECEF~$\to$~Local Level, and Geodetic~$\to$~Local
Level.  Note that for the ECEF~$\to$~Local Level, you will \emph{first} need to
convert the given geodetic (\texttt{lat}, \texttt{lon}, \texttt{h}) coordinates
to ECEF, and then convert to a local level frame.  You are given a python 
function to convert from geodetic (\texttt{lat}, \texttt{lon}, \texttt{h}) 
to ECEF (\texttt{x}, \texttt{y}, \texttt{z}): \texttt{llh2ecef.py}.

The origin of your local level frame should be the starting point of the flight,
but with an altitude of zero.  (The starting \texttt{lat} and \texttt{lon} are
the first elements of each array.)  Remember that when converting from
ECEF~$\to$~Local Level, the $3\times 3$ direction cosine matrix (DCM) that you
use to rotate the ECEF vector to the local level frame should only be calculated
once, based on the origin coordinates, and that DCM should be used for every
subsequent rotation.

Now you should have two different local level coordinates: one generated by
converting to ECEF and then using the ECEF~$\to$~Local Level method, and one
generated by using the Geodetic~$\to$~Local Level method.  Both should represent
east, north, and up distance from the origin in meters.  Notationally, let us
call these \texttt{enuE2L} (ECEF~$\to$~Local Level) and \texttt{enuG2L}
(Geodetic~$\to$~Local Level).

Generate the following plots:
\begin{enumerate}
   \item Horizontal plot of horizontal position (east and north) for both
      trajectories in the same plot (distinguish by color)
   \item A plot of \texttt{enuE2L} altitude versus time and \texttt{enuG2L}
      altitude versus time on the same plot (distinguish by color)
   \item A plot of the difference between \texttt{enuE2L} and \texttt{enuG2L}
      (i.e., \texttt{enuDIFF = enuE2L - enuG2L}) versus time for all three
      values: east, north, and up.
\end{enumerate}

In the video, it was stated that the two approaches (ECEF~$\to$~Local Level and
Geodetic~$\to$~Local Level) are equivalent as long as you are ``close'' to the
origin of the local level frame.  Let us quantify how close you need to be.
Based on the plots that you have (especially the third plot), answer the
following questions:
\begin{enumerate}
   \item From plot 2, why does the height become negative for the
      \texttt{enuE2L} representation?
   \item In what sense could you say that both heights (\texttt{enuE2L} and
      \texttt{enuG2L} heights) are correct in their own ways?
   \item From plot 3, what is the maximum distance from the origin of the local
      level frame you can go in order to keep the maximum altitude difference
      from being more than 1~cm?  (Recall that you are flying at 300~m/s, so
      knowing time you can also know distance flown).
   \item Also, from plot 3, what is the maximum distance from the origin of the
      local level frame you can go in order to keep both the east and north
      difference from being more than 1~cm?
\end{enumerate}

\section*{\textsf{Deliverables}}

For this project, submit via Canvas the following:

\begin{itemize}
   \item The python source code used for calculation and plotting
   \item The three plots specified
   \item The answers to the four questions
\end{itemize}

\section*{\textsf{Grading}}

This project is graded on a 100-point scale.  If your results do not seem to be
correct or have anomalies, please point that out.  I will deduct more points for
errors that are present which you did not seem to realize were errors than for
errors which are present but recognized as errors based on your comments.

\end{document}
